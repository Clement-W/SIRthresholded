---
title: "How to use the SIRthresholded package"
author: "ClÃ©ment Weinreich"
date: "`r Sys.Date()`"
output:
    html_document: rmarkdown::html_vignette
    #pdf_document: default
vignette: |
    %\VignetteIndexEntry{How to use the SIRthresholded package}
    %\VignetteEngine{knitr::rmarkdown} 
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo=TRUE,eval=TRUE,comment="#>")
```

__Table of content__

- [How SIR and SIR thresholded works](#how-sir-and-sir-thresholded-works)
- [Overview of the package](#overview-of-the-package)
- [Example with simulated data](#example-with-simulated-data)
- [Example with wine dataset](#example-with-wine-dataset)

---

This package offers an implementation of the $SIR$ (Sliced Inverse Regression) method, along with a thresholded version of $SIR$ that allows variable selection. The purpose of this vignettes is to explain the function implemented in the package, and how they are used. The first section is dedicated to the theoretical explaination of $SIR$, and its thresholded version. Reading this section is therefore optional, but can be useful to better understand how the package functions work.


## How SIR and SIR thresholded works

### The semi-parametric model

Consider the following semi-parametric model:
$$Y = g(\beta'X,\epsilon)$$
where:

-   $Y \in \mathbb{R}$ is a univariate response variable
-   $X \in \mathbb{R}^p$ is a $p$-dimensional covariates such as $\mathbb{E}(X)=\mu$ and $\mathbb{V}(X)=\Sigma$
-   $\beta$ is a vector generating a direction of $\mathbb{R}^p$
-   $\epsilon$ is the random error term, assumed independant of $X$
-   $g$ is an arbitrary link function (unknown)

It is common to present the model as $Y\perp X\mid \beta'X$ which means that $Y$ is independent of $X$ conditional on $\beta'X$. Thus, it is possible to replace $X\in\mathbb{R}^p$ with the index $\beta'X\in\mathbb{R}$ without loss of information in the regression of $Y$ on $X$. Thus, we do dimension reduction of the explanatory part $X$ from $p$-dimension to $1$-dimension, without specifying either the relationship between the index $\beta'X$ and $Y$ or the distribution of the error term $\epsilon$.

In the framework of this model, $g$ being unknown, we cannot identify $\beta$, but we can identify its direction. We then define the $EDR$ (Effective Dimension Reduction) space $E$ as the linear subspace of $\mathbb{R}^p$ generated by $\beta$. Any vector belonging to $E$ is then an $EDR$ direction.

### The SIR method

The $SIR$ method is used to obtain the estimate of an $EDR$ direction. In theory, the $SIR$ method requires a condition on the distribution of the explanatory variable $X$ called the linearity condition: $\forall b \in\mathbb{R}^p, \mathbb{E}[b'X\mid\beta'X]$ is linear in $X'\beta$. In practice, it is impossible to verify this assumption because $\beta$ is unknown and unidentifiable. However, this assumption is valid when the distribution of $X$ is elliptical, which is the case for the multidimensional normal distribution.

Let's now consider a monotonic transformation $T$ (which in the case of the SIR method will correspond to a slicing function). Under the previous model and the linearity condition, (Duan & Li, 1991) showed that the centered inverse regression curve verifies :
$$\mathbb{E}[X\mid T(Y)] - \mu \in \mbox{Span}(\Sigma\beta)$$
Thus, the subspace generated by this curve, ${\mathbb{E}[X \mid T(Y)] - \mathbb{E}[X] : Y \in \mathcal{Y}}$ (where $\mathcal{Y}$ is the support for the response variable $Y$), belongs to the $EDR$ space. Therefore, the centered inverse regression curve can clearly be used to find the $EDR$ space.

A direct consequence of this result, is that the variance covariance matrix of this curve, $\Gamma = \mathbb{V}(\mathbb{E}[X \mid T(Y)])$, is degenerate in any direction $\Sigma$-orthogonal to $\beta$. Therefore, the eigenvector associated with the largest nonzero eigenvalue of the matrix of interest $\Sigma^{-1}\Gamma$ is an $EDR$ direction, so it generates the $EDR$ space $E$.

In the slicing step of the $SIR$ method, the support of $Y$ is sliced into $H$ slices $\{s_1,\dots,s_H\}$. With a function $T$ corresponding to this slicing, the matrix $\Gamma$ can then be written as
$$\Gamma=\sum_{h=1}^Hp_h(m_h-\mu)(m_h-\mu)'$$
where $p_h=P(Y\in s_h)$ is the theoretical proportion of $Y_i$ falling in the $s_h$ slice and $m_h=\mathbb{E}[X\mid Y\in s_h]$ is the theoretical mean of $X_i$ associated with $Y_i$ falling in the $s_h$ slice. This matrix $\Gamma$ is therefore easy to estimate.

\

Let us consider a sample $\{(X_i,Y_i), i=1,\dots,n\}$ generated from the previous model. In practice, it is necessary to replace the theoretical moments $\mu, \Sigma, p_h$ and $m_h$ by the empirical moments. Then, an estimator of a basis of the $EDR$ space $E$ is obtained via the eigenvector $\hat{b}$ associated to the largest eigenvalue of the estimator $\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n$ of $\Sigma^{-1}\Gamma$ where :

-   $\widehat{\Sigma}_n=  \frac{1}{n} \sum_{i=1}^n (X_i - \bar{X}_n)(X_i -\bar{X}_n)'$ is the empirical variance covariance matrix of $X$

-   $\widehat{\Gamma}_n= \sum_{h=1}^H\hat p_{h,n} (\hat m_{h,n} - \bar{X}_n)(\hat m_{h,n} -\bar{X}_n)'$ is the empirical variance covariance matrix of the empirical means of $X$ per slices $s_h$

with :

-   $\bar{X}_n= \frac{1}{n}\sum_{i=1}^nX_i,$ the empirical mean of the sample

-   $\hat p_{h,n} = \frac{1}{n}\sum_{i=1}^{n} \mathbb{I} {[Y_i\in {s_h} ]}  = \frac{\hat{n}_{h,n}}{n}$ the empirical proportion of $Y_i$ falling in the slice $s_h$ (where $n_{h,n}$ is the number of $Y$ falling in the slice $s_h$)

-   $\hat m_{h,n}=\frac{1}{\hat{n}_{h,n}  }\sum_{i\in {s_h}}X_i$ the empirical mean of $X_i$ such that $Y_i$ falls into the slice $h$

### Variable selection by soft or hard thresholding

It is possible to perform variable selection in SIR regression. The method presented here is a computational method using soft or hard thresholding of the matrix of interest.
Let us define the soft thresholding ($S$ as in soft) and hard thresholding ($H$ as in hard) operators that apply to any matrix $M$ of dimension $p\times p$. For any real $\lambda\geq 0$ and $(i,j)\in \{1,\dots,p\}\times \{1,\dots,p\}$ :

$$
S_\lambda(M)_{i,j}= sign(M_{i,j}) \times \begin{cases}
      \lvert M_{i,j} \rvert -\lambda & \mbox{if } \lvert M_{i,j} \rvert -\lambda >0, \\
      0 & \text{otherwise.}
    \end{cases}
$$

$$
H_\lambda(M)_{i,j}= \begin{cases}
       M_{i,j}  & \mbox{if } \lvert M_{i,j} \rvert -\lambda >0, \\
      0 & \text{otherwise.}
    \end{cases}
$$

with $sign$ the function that returns the sign of the considered element ($1$ if positive, $0$ if null and $-1$ if negative).

We then introduce two new methods:

-   $ST-SIR$ for soft thresholding of the matrix of interest of the SIR approach, which considers the matrix $S_\lambda(\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n)$,
-   $HT-SIR$ for hard thresholding of the matrix of interest of the SIR approach, which considers the matrix $H_\lambda(\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n)$.

For each approach, an eigenvector associated to the largest eigenvalue of $S_\lambda(\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n)$ or $H_\lambda(\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n)$ is computed, for a given value of $\lambda$.

The choice of the thresholding hyper-parameter $\lambda$ must provide a balance between

-   correct variable selection (by tilting some of the components of the considered eigenvector to $0$)
-   low distortion of the estimated direction $\hat{b}$

Then, once the $p^{\star}$ useful variables have been identified, a new $SIR$ model can be estimated on the basis of these $p^{\star}$ selected variables. Thus, the estimation of $\beta$ will be easier because the estimation is done in a space of reduced dimension.

## Overview of the package

### `SIR` function

Apply a single-index $SIR$ on $(X,Y)$ with $H$ slices. This function allows to obtain an estimate of a basis of the $EDR$ (Effective Dimension Reduction) space via the eigenvector $\hat{b}$ associated with the largest nonzero eigenvalue of the matrix of interest $\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n$. Thus, $\hat{b}$ is an $EDR$ direction.

### `SIR_bootstrap` function

Apply a single-index $SIR$ on $B$ bootstraped samples of $(X,Y)$ with $H$ slices.

### `SIR_threshold` function

Apply a single-index $SIR$ on $(X,Y)$ with $H$ slices, with a parameter $\lambda$ which apply a soft/hard thresholding to the interest matrix $\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n$.

### `SIR_threshold_opt` function

Apply a single-index SIR on $(X,Y)$ with $H$ slices, with a soft/hard thresholding of the interest matrix $\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n$ by an optimal parameter $\lambda_{opt}$. The $\lambda_{opt}$ is found automatically among a vector of `n_lambda` $\lambda$, starting from 0 to the maximum value of $\widehat{\Sigma}_n^{-1}\widehat{\Gamma}_n$. For each feature of $X$, the number of $\lambda$ associated with a selection of this feature is stored (in a vector of size $p$). This vector is sorted in a decreasing way. Then, thanks to `strucchange::breakpoints`, a breakpoint is found in this sorted vector. The coefficients of the variables at the left of the breakpoint, tend to be automatically toggled to 0 due to the thresholding operation based on $\lambda_{opt}$, and so should be removed (useless variables). Finally, $\lambda_{opt}$ corresponds to the first $\lambda$ such that the associated $\hat{b}$ provides the same number of zeros as the breakpoint's value.

For example, for $X \in \mathbb{R}^{10}$ and `n_lambda=100`, this sorted vector can look like this :

| X10 | X3  | X8  | X5  | X7  | X9  | X4  | X6  | X2  | X1  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 2   | 3   | 3   | 4   | 4   | 4   | 6   | 10  | 95  | 100 |

Here, the breakpoint would be 8.

### `SIR_threshold_bootstrap` function

Apply a single-index optimally soft/hard thresholded $SIR$ with $H$ slices on `n_replications` bootstraped replications of $(X,Y)$. The optimal number of selected variables is the number of selected variables that came back most often among the replications performed. From this, we can get the corresponding $\hat{b}$ and $\lambda_{opt}$ that produce the same number of selected variables in the result of `SIR_threshold_opt`.

This method allow to validate the robustness of the model.

## Example with simulated data

In this section :

- [(1)](#generate-the-data) A dataset is created.
- [(2)](#create-a-sir-model) Classic SIR is applied to this dataset. The outputs from the S3 summary and plot methods are described.
- [(3)](#use-optimally-thresholded-sir) SIR optimally thresholded is applied to this dataset in order to do variable selection. The outputs from the S3 summary and plot methods are described.
- [(4)](#estimate-a-new-sir-model-on-the-relevant-variables) A new SIR model is estimated on the relevant variables, selected by SIR thresholded. We notice that the estimation of the EDR direction is better than with the classic SIR method.
- [(5)](#sir-thresholded-with-a-given-lambda-parameter) SIR thresholded is applied on the dataset with a custom $\lambda$ parameter.
- [(6)](#test-the-robustness-of-the-model-with-bootstrapping) A bootstrapped version of SIR optimally thresholded is applied to the data, in order to ensure the robustness of the model. The outputs from the S3 summary and plot methods are described.

### Generate the data

Let's create $Y = (X\beta)^3 + \epsilon$ with:

-   $n=200$ (Sample size)
-   $X\in \mathbb{R}^p$ and $X\sim\mathcal{N}(0,\mathbb{I}_p)$
-   $p=30$ and $p^\star=10$ ($10$ relevant variables in $X$)
-   $\epsilon\sim\mathcal{N}(0,20)$ and $\epsilon \perp \!\!\! \perp X$.

```{r}
set.seed(4)
n <- 200 # Sample size
p <- 30 # Number of variables in X
p_star <- 10 # Number of relevant variables in X
X <- mvtnorm::rmvnorm(n,sigma=diag(p)) # X ~ N(0,I_p)
dimnames(X) <- list(1:n, paste("X", 1:p, sep = "")) # Rename columns of X

eps <- rnorm(n, sd = 20) # Error

beta <- matrix(c(rep(1,p_star),rep(0,p-p_star)),ncol=1) # Beta = Heaviside function
rownames(beta) <- colnames(X) # Rename rows of X

Y <- (X %*% beta)**3 + eps # The model
```

We can now plot Y versus the reconstructed index $X\beta$

```{r,fig.align='center',fig.width=5,fig.asp=1,out.width="300px"}
plot(X %*% beta, Y, xlab = "true index")
```

### Create a SIR model

```{r}
library(SIRthresholded)
```

The `SIR` function is applied to these data.

```{r}
res_SIR = SIR(Y = Y, X = X, H = 10,graph = FALSE)
```

The object `res_SIR` is an object of class `SIR` and contains many numerical results (see ?SIR for more details), summarized in the S3 methods `print` and `summary`.

```{r}
summary(res_SIR)
```

You can now access the estimation of the EDR direction with `res_SIR$b`. Thus, it is possible to compute the correlation between $\beta$ and $\hat{b}$ :

```{r}
cor(c(beta),c(res_SIR$b))
```

Here are the two graphical outputs obtained with the method `plot` of the objects of class `SIR`.

```{r,fig.asp=1,fig.show='hold',fig.width=5,out.width="300px",fig.align='center',fig.cap=' '}
plot(res_SIR,choice="estim_ind")
plot(res_SIR,choice="eigvals")
```

The first plot shows the reconstructed index by plotting $Y$ versus $X\hat{b}$ with $\hat{b}$ the estimated $EDR$ direction.

The second one shows the ten largest eigenvalues of the interest matrix. The $EDR$ direction is the eigenvector $\hat{b}$ associated with the largest eigenvalue. This plot can be useful to check if the largest eigenvalues are very close or not. In the case where they are close, it could be interesting to try to choose the second or third largest eigenvector to reconstruct the index. You can access the interest matrix with `res_SIR$M1`, and then compute the eigenvectors and eigenvalues with the function `eigen()`.

By looking at $\hat{b}$, we notice that the coefficient associated to some variables are close to $0$. We assume that some variables are useless and that it would be interesting to do variable selection.

### Use optimally thresholded SIR

An other approach is to directly use the optimally thresholded version of $SIR$ which will provide an estimate of the $EDR$ direction, and select the relevant variables. Let's start with $ST-SIR$ (soft thresholded SIR) with 100 $\lambda$ values to test :

```{r}
res_STSIR = SIR_threshold_opt(Y=Y, X=X, H=10, n_lambda=100, thresholding="soft", graph=FALSE)
```

The object `res_STSIR` is an object of class `SIR_threshold_opt` and contains many numerical results (see ?SIR_threshold_opt for more details), summarized in the S3 methods `print` and `summary`.

```{r}
summary(res_STSIR)
```

Here are some graphical outputs obtained with the method `plot` of the objects of class `SIR_threshold_opt`.

```{r,fig.width=7,out.width="450px",fig.asp=1,fig.align='center'}
plot(res_STSIR,choice="cos2_selec")
```

This plot shows the evolution of $cos^2(\hat{b}_{ST-SIR},\hat{b}_{SIR})$ and the percentage of variables selected by the model, according to the value of $\lambda$. This graph is very informative as it shows the compromise between variable selection and distortion of the estimated direction. The $\hat{\lambda}_{opt}$ must provide a balance between these two.

```{r,fig.width=7,out.width="450px",fig.asp=1,fig.align='center'}
plot(res_STSIR,choice="opt_lambda")
```

This plot shows how the optimal lambda has been chosen. For each feature of $X$, the percentage of $\lambda$ associated with a selection of this feature is stored in a vector, which is sorted and plotted here. Thanks to `strucchange::breakpoints`, a breakpoint is found in this sorted vector, which allows to deduce the $\lambda_{opt}$ as explained in the [Overview](#overview).

```{r,fig.width=7,out.width="500px",fig.asp=1,fig.align='center'}
plot(res_STSIR,choice="regul_path")
```

This plot shows the regularization path of $\hat{b}$ according to the value of $\lambda$. Here, we can see that according to $\lambda$, some variables rapidly converge to 0, whereas the 10 relevant variables are more difficult to toggle to 0.

Then, let's plot plot Y versus the estimated first index $X\hat{b}$.

```{r,fig.align='center',fig.width=5,fig.asp=1,out.width="300px"}
plot(res_STSIR,choice="estim_ind")
```

We can also see some graphical outputs of `SIR_threshold_opt` with hard thresholding :

```{r,fig.asp=1,fig.show='hold',fig.width=8,out.width="330px",fig.align='center',fig.cap=' '}
res_HTSIR = SIR_threshold_opt(Y=Y, X=X, H=10, n_lambda=100, thresholding="hard", graph=FALSE)

plot(res_HTSIR,choice="cos2_selec")
plot(res_HTSIR,choice="regul_path")
```

The hard thresholding method results in a more abrupt variable selection according to the $\lambda$s, wich explains that the curves are straighter with bigger jumps between values.

### Estimate a new SIR model on the relevant variables

As the soft thresholding deforms the matrix of interest with the $\lambda$ parameter, the estimation of $\hat{b}$ is biased. That is why, at the end of the S3 summary method, it is proposed to create a new SIR model based only on the relevant variables, selected by the method. Let's copy paste the command line from the result of `SIR_threshold_opt` and see the results:

```{r}
res_SIR_pstar = SIR(Y=res_STSIR$Y, X=res_STSIR$X_reduced, H=res_STSIR$H)
summary(res_SIR_pstar)
```

Let's plot Y versus the estimated first index $X\hat{b}$

```{r,fig.align='center',fig.width=5,fig.asp=1,out.width="300px"}
plot(res_SIR_pstar,choice="estim_ind")
```

We directly notice that this estimated index is very close to the theoretical index plotted earlier.

As done previously, let's compute the correlation between $\beta$ and $\hat{b}_{ST-SIR-p^\star}$ and compare it with the results of classic SIR. As the real $\beta$ vector has a length of 30 and $\hat{b}_{ST-SIR-p^\star}$ has a length of 10, we need to create a new vector of size 30 to be able to compare them.

```{r}
b_extended <- matrix(rep(0,p),nrow=1) # Create the empty vector
colnames(b_extended) <- colnames(X) # Assign the colnames of X
# Assign the values of b_extended according to the colnames
b_extended[which(colnames(b_extended) %in% colnames(res_SIR_pstar$b))] = res_SIR_pstar$b
```

Let's compute the correlation :

```{r}
cor(c(beta),c(b_extended))
```

We notice that the estimation of $\beta$ is better than the classic $SIR$ method (95% for $SIR$ and 99% for $ST-SIR-p^\star$). The 20 useless variables have been eliminated, and the estimation of the $EDR$ direction is very good.

Wether using hard or soft thresholding, it is always relevent to create a new $SIR$ model considering only the relevant variables. It allows to improve the estimation of the $EDR$ direction.

### SIR thresholded with a given $\lambda$ parameter

If you want to experiment the thresholding operation by yourself, you can call `SIR_threshold` and give your own $\lambda$ to threshold the interest matrix :

```{r}
res_SIR_thresh = SIR_threshold(Y, X, H = 10, lambda = 0.04, thresholding = "hard")
summary(res_SIR_thresh)
```

### Test the robustness of the model with bootstrapping

To test the robustness of the model, it is relevant to perform bootstrapping. This method is even more relevant when the sample size is small. Lets call `SIR_threshold_bootstrap` on the data, with 10 replications (only 10 to simplify vignettes building), a bootstrapped sample size multiplied by 2 (k=2) and the hard thresholding method :

```{r}
res_SIR_boot = SIR_threshold_bootstrap(Y,X,H=10,n_lambda=100,thresholding="hard", n_replications=10,k=2,graph = FALSE)
```

The object `res_SIR_boot` is an object of class `SIR_threshold_bootstrap` and contains many numerical results (see ?SIR_threshold_bootstrap for more details), summarized in the S3 methods `print` and `summary`.

```{r}
summary(res_SIR_boot)
```

Here are some graphical outputs obtained with the method `plot` of the objects of class `SIR_threshold_bootstrap`.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res_SIR_boot,choice="size")
```

This barplot shows the distribution of the number of variables keeped by the model.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res_SIR_boot,choice="selec_var")
```

This barplot shows the percentage of selection by the model for every variables.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res_SIR_boot,choice="lambdas_replic")
```

This boxplot shows the distribution of the $\lambda_{opt}$ choosen over the replications. Moreover, the $\lambda_{opt}$ that has been selected (see how in [the overview](#sir_threshold_bootstrap-function)) is indicated with a purple horizontal line.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res_SIR_boot,choice="coefs_b")
```

This plot shows the distribution of every coefficients of the $\hat{b}$ computed over the replications. The final coefficients of $\hat{b}$ that have been computed (see how in [the overview](#sir_threshold_bootstrap-function)) are indicated with a purple dot.

As done with `SIR_threshold_opt`, we can also create a new SIR model considering only the relevant variables.

## Example with Wine dataset

In this section :

- [(1)](#the-data) Load the wine dataset.
- [(2)](#a-first-sir-model) A first SIR model optimally thresholded is applied to the data.
- [(3)](#perform-bootstrap) A bootstrapped version of SIR optimally thresholded is applied to the data.
- [(4)](#thresholding-with-a-custom-lambda) A SIR model thresholded with a custom $\lambda$ is applied to the data. 
- [(5)](#estimate-a-sir-model-on-the-relevant-variables) A SIR model is applied on the relevant variables
- [(6)](#additional-study) Additional study of the quality of the model with multiple linear regression
- [(7)](#concluding-remarks) Concluding remarks

### The data

For this example, we chose the wine dataset from the UCI machine learning repository (https://archive.ics.uci.edu/ml/datasets/Wine). As explained on the page description of the dataset, these data are the results of a chemical analysis of wines grown in the same region in Italy. The analysis determined the quantities of 12 constituents found in the 178 samples of wine. Here, we'll try to find the relevant variables in order to perform regression on the response variable Nonflavanoids according to the 12 other constituents. First, let's load the dataset.

```{r}
wine <-  read.csv("https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data", header = FALSE) 
colnames(wine) <- c('Type', 'Alcohol', 'Malic', 'Ash', 'Alcalinity', 'Magnesium', 
                    'Phenols', 'Flavanoids', 'Nonflavanoids', 'Proanthocyanins', 
                    'Color', 'Hue', 'Dilution', 'Proline')

# Extract the response variable
Y <- wine$Nonflavanoids
# Remove the response variable (Nonflavanoids) and the class information (type of cultivars)
X <- wine[, -which(names(wine) %in% c("Type","Nonflavanoids"))] 

head(cbind(Y,X),3)
print(dim(X))
```

The X data contains 178 samples of 12 variables. As suggested in the description page of this dataset, we'll standardise the variables with the `scale()` method. Here, scaling the data is mandatory to ensure that the SIR method works properly.
```{r}
X = scale(X)
Y = scale(Y)
```

### A first SIR model

Now, we can use `SIR_threshold_opt` to do variable selection with an optimal thresholding parameter. The sample size is relatively small. To improve the estimations of $p_h$ and $m_h$ in the SIR method (more details in [the first part of this vignette](#how-sir-and-sir-thresholded-works)), we reduce the number of slices to 5, so there is more sample in each slices.

```{r}
res1 = SIR_threshold_opt(Y=Y, X=X, H=5, n_lambda=300, thresholding="soft", graph=FALSE)
summary(res1)
```

In this first model, 2 variables are selected : Ash and Flavanoids. Let's  explore the graphs to better understand what is going on.

```{r,fig.align='center',fig.width=5,fig.asp=1,out.width="300px"}
plot(res1,choice="estim_ind")
```

We first note that the model is very noisy. However, we still notice a linear tendency between the estimated index and Y.

Let's now focus on variable selection.

```{r,fig.asp=1,fig.show='hold',fig.width=8,out.width="400px",fig.align='center',fig.cap=' '}
plot(res1,choice="cos2_selec")
plot(res1,choice="regul_path")
```

These two graphs helps us to understand the link between variable selection (the coefficients of $\hat{b}$) and $\lambda$. Here, the $\lambda_{opt}$ allows to select 2 variables. In the first plot, we notice that if $\lambda$ were a bit less than $\lambda_{opt}$, we could have selected 2 or 3 more variables, while improving the estimation of $\hat{b}$. In fact, in the second plot, we notice that the coefficients of $\hat{b}$ associated to the variables Dillution, Magnesium and Hue are set to 0 by $\lambda_{opt}$.

### Perform Bootstrap

As the data is noisy, the sample size is small, and the $\lambda_{opt}$ obtained with `SIR_threshold_opt` is questionable, it is relevant to perform SIR_threshold_opt on bootstrapped replications of the dataset. Let's perform 500 replications, with a bootstrapped sample size multiplied by 2 :

```{r}
# To lighten the build of the vignette, the result of this command was saved into a RData file.
#res2 = SIR_threshold_bootstrap(Y=Y, X=X, H=5, n_lambda=200, thresholding="hard", n_replications = 500 , graph=FALSE)
load("../R/sysdata.rda") # load res2
summary(res2)
```

Let's explore some of the graphical outputs :
```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res2,choice="size")
```

Over the 500 replications, 50% of the models selected 2 variables. Then, approximately 45% of the models selected 3,4,5 or 6 variables. Let's take a look at the percentage of variable selection.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res2,choice="selec_var")
```

As expected, a large majority of the models have selected the variables Ash and Flavanoids. But it is interesting to see that 4 other variables were regularly selected (between 30 and 40% of the replications) : Magnesium, Phenols, Hue and Dilution. We notice that these variables were closed to be selected in `SIR_threshold_opt`.

```{r,fig.align='center',fig.width=9,fig.asp=1,out.width="400px"}
plot(res2,choice="coefs_b")
```

Looking at the boxplot of the value of $\hat{b}$ over the 500 replications, we also find the same results. The coefficients of $\hat{b}$ associated to Magnesium, Phenols, Hue and Dilution are greater than 0 in median. It would then be interesting to create a SIR model, that contains these variable.

### Thresholding with a custom $\lambda$

Let's look at the regularization path plotted earlier, and find the $\lambda$ which select the 4 potentially relevant variables. By looking at the top axis of the regularization path, we find the first lambda which select 6 variables, which is approximately 0.07 :

```{r}
res3 = SIR_threshold(Y=Y, X=X, H=5, lambda = 0.071, thresholding="hard", graph=FALSE)
summary(res3)
```

Now, the 6 variables are selected with this estimation of $\hat{b}.$. Let's estimate a new SIR model only on these relevant variables.

### Estimate a SIR model on the relevant variables

Let's copy paste the command from the previous output of the S3 summary method, and plot the estimated index versus Y :

```{r}
res4 = SIR(Y=res3$Y, X=res3$X_reduced, H=res3$H, graph = FALSE)
summary(res4)
```

```{r,fig.align='center',fig.width=5,fig.asp=1,out.width="300px"}
plot(res4,choice="estim_ind")
```

We can note that the estimated index seems to be a bit less noisy, the linear tendency is easier to see.

### Additional study

Visually, the link between Y and X seems to be linear. To estimate the quality of our model, and to evaluate the relevance of the selected variable, we can build a linear model on the data.

Let's start with a model containing every variables :

```{r}
summary(lm(Y~X))
```
The R-squared is equal to 44.33%, so aproximately 44% of the variability is explained by this model. We also notice that the coefficients associated to the variables Ash, Magnesium, Flavanoids, Hue and Dilution are significants.

Let's compare with the R-squared obtained with the variables selected by the previous SIR model :

- [The first model res1](#a-first-sir-model) which selected Flavanoids and Ash :
    ```{r}
    summary(lm(Y~Flavanoids+Ash,data=wine))$r.squared
    ```

- [The model with a custom thresholding parameter res3](#thresholding-with-a-custom-lambda) which selected Flavanoids, Ash, Magnesium, Dilution, Phenols, Hue :
    ```{r}
    summary(lm(Y~Ash+Magnesium+Phenols+Flavanoids+Hue+Dilution,data=wine))$r.squared
    ```

The best compromise seems to be the SIR model that keep 6 variables. The R-squared is almost identical (-1%) and half of the variables have been kept.

### Concluding remarks

The package SIRthresholded helped us to find the relevant variables, in order to create the best non-parametric regression on the response variable Nonflavanoids. This example shown that only using `SIR_threshold_opt` can be limiting on real data, especially when the data is noisy with a small sample size. The method `SIR_threshold_bootstrap` helped us to counter this issue, and retrieve important information about the potential relevant variables. Finally, the best model is `res4` which is a SIR model only based on the 6 relevant variables : Flavanoids, Ash, Magnesium, Dilution, Phenols, Hue.  

## References

Duan, N., & Li, K.-C. (1991). Slicing Regression : A Link-Free Regression Method. The Annals of Statistics, 19(2), 505â530.

Dua, D. and Graff, C. (2019). UCI Machine Learning Repository [https://archive.ics.uci.edu/ml/]. Irvine, CA: University of California, School of Information and Computer Science.
